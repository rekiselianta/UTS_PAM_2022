{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GestureDetector = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _gesture2 = require(\"./gesture\");\n\nvar _reanimatedWrapper = require(\"./reanimatedWrapper\");\n\nvar _handlersRegistry = require(\"../handlersRegistry\");\n\nvar _RNGestureHandlerModule = _interopRequireDefault(require(\"../../RNGestureHandlerModule\"));\n\nvar _gestureHandlerCommon = require(\"../gestureHandlerCommon\");\n\nvar _gestureStateManager = require(\"./gestureStateManager\");\n\nvar _FlingGestureHandler = require(\"../FlingGestureHandler\");\n\nvar _ForceTouchGestureHandler = require(\"../ForceTouchGestureHandler\");\n\nvar _LongPressGestureHandler = require(\"../LongPressGestureHandler\");\n\nvar _PanGestureHandler = require(\"../PanGestureHandler\");\n\nvar _TapGestureHandler = require(\"../TapGestureHandler\");\n\nvar _State = require(\"../../State\");\n\nvar _EventType = require(\"../../EventType\");\n\nvar _ActionType = require(\"../../ActionType\");\n\nvar _utils = require(\"../../utils\");\n\nvar _getShadowNodeFromRef = require(\"../../getShadowNodeFromRef\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _Reanimated$default$c, _Reanimated$default;\n\nvar ALLOWED_PROPS = [].concat((0, _toConsumableArray2.default)(_gestureHandlerCommon.baseGestureHandlerWithMonitorProps), (0, _toConsumableArray2.default)(_TapGestureHandler.tapGestureHandlerProps), (0, _toConsumableArray2.default)(_PanGestureHandler.panGestureHandlerProps), (0, _toConsumableArray2.default)(_PanGestureHandler.panGestureHandlerCustomNativeProps), (0, _toConsumableArray2.default)(_LongPressGestureHandler.longPressGestureHandlerProps), (0, _toConsumableArray2.default)(_ForceTouchGestureHandler.forceTouchGestureHandlerProps), (0, _toConsumableArray2.default)(_FlingGestureHandler.flingGestureHandlerProps));\n\nfunction convertToHandlerTag(ref) {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof _gesture2.BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    var _ref$current$handlerT, _ref$current;\n\n    return (_ref$current$handlerT = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.handlerTag) !== null && _ref$current$handlerT !== void 0 ? _ref$current$handlerT : -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup) {\n  var _interactionGroup$map, _interactionGroup$map2;\n\n  return (_interactionGroup$map = interactionGroup === null || interactionGroup === void 0 ? void 0 : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === null || _interactionGroup$map2 === void 0 ? void 0 : _interactionGroup$map2.filter(function (tag) {\n    return tag > 0;\n  })) !== null && _interactionGroup$map !== void 0 ? _interactionGroup$map : [];\n}\n\nfunction dropHandlers(preparedGesture) {\n  for (var _iterator = _createForOfIteratorHelperLoose(preparedGesture.config), _step; !(_step = _iterator()).done;) {\n    var handler = _step.value;\n\n    _RNGestureHandlerModule.default.dropGestureHandler(handler.handlerTag);\n\n    (0, _handlersRegistry.unregisterHandler)(handler.handlerTag, handler.config.testId);\n  }\n}\n\nfunction checkGestureCallbacksForWorklets(gesture) {\n  if (gesture.config.runOnJS) {\n    return;\n  }\n\n  var areSomeNotWorklets = gesture.handlers.isWorklet.includes(false);\n  var areSomeWorklets = gesture.handlers.isWorklet.includes(true);\n\n  if (areSomeNotWorklets && areSomeWorklets) {\n    console.error((0, _utils.tagMessage)(\"Some of the callbacks in the gesture are worklets and some are not. Either make sure that all calbacks are marked as 'worklet' if you wish to run them on the UI thread or use '.runOnJS(true)' modifier on the gesture explicitly to run all callbacks on the JS thread.\"));\n  }\n}\n\nfunction attachHandlers(_ref) {\n  var preparedGesture = _ref.preparedGesture,\n      gestureConfig = _ref.gestureConfig,\n      gesture = _ref.gesture,\n      viewTag = _ref.viewTag;\n\n  if (!preparedGesture.firstExecution) {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  setImmediate(function () {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n  });\n\n  var _loop = function _loop(handler) {\n    checkGestureCallbacksForWorklets(handler);\n\n    _RNGestureHandlerModule.default.createGestureHandler(handler.handlerName, handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS));\n\n    (0, _handlersRegistry.registerHandler)(handler.handlerTag, handler, handler.config.testId);\n    setImmediate(function () {\n      var requireToFail = [];\n\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      var simultaneousWith = [];\n\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);\n      }\n\n      _RNGestureHandlerModule.default.updateGestureHandler(handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n    });\n  };\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(gesture), _step2; !(_step2 = _iterator2()).done;) {\n    var handler = _step2.value;\n\n    _loop(handler);\n  }\n\n  preparedGesture.config = gesture;\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(preparedGesture.config), _step3; !(_step3 = _iterator3()).done;) {\n    var _gesture = _step3.value;\n    var actionType = _gesture.shouldUseReanimated ? _ActionType.ActionType.REANIMATED_WORKLET : _ActionType.ActionType.JS_FUNCTION_NEW_API;\n\n    _RNGestureHandlerModule.default.attachGestureHandler(_gesture.handlerTag, viewTag, actionType);\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    var isAnimatedGesture = function isAnimatedGesture(g) {\n      return g.shouldUseReanimated;\n    };\n\n    preparedGesture.animatedHandlers.value = gesture.filter(isAnimatedGesture).map(function (g) {\n      return g.handlers;\n    });\n  }\n}\n\nfunction updateHandlers(preparedGesture, gestureConfig, gesture) {\n  gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n\n  for (var i = 0; i < gesture.length; i++) {\n    var handler = preparedGesture.config[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  setImmediate(function () {\n    for (var _i = 0; _i < gesture.length; _i++) {\n      var _handler = preparedGesture.config[_i];\n      _handler.config = gesture[_i].config;\n      _handler.handlers = gesture[_i].handlers;\n      var requireToFail = extractValidHandlerTags(_handler.config.requireToFail);\n      var simultaneousWith = extractValidHandlerTags(_handler.config.simultaneousWith);\n\n      _RNGestureHandlerModule.default.updateGestureHandler(_handler.handlerTag, (0, _gestureHandlerCommon.filterConfig)(_handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n\n      (0, _handlersRegistry.registerHandler)(_handler.handlerTag, _handler, _handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = preparedGesture.config.filter(function (g) {\n        return g.shouldUseReanimated;\n      }).map(function (g) {\n        return g.handlers;\n      });\n    }\n  });\n}\n\nfunction needsToReattach(preparedGesture, gesture) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n\n  for (var i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName || gesture[i].shouldUseReanimated !== preparedGesture.config[i].shouldUseReanimated) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(preparedGesture, needsRebuild) {\n  if (!_reanimatedWrapper.Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(event) {\n    'worklet';\n\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(event) {\n    'worklet';\n\n    return event.eventType != null;\n  }\n\n  function getHandler(type, gesture) {\n    'worklet';\n\n    switch (type) {\n      case _gesture2.CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n\n      case _gesture2.CALLBACK_TYPE.START:\n        return gesture.onStart;\n\n      case _gesture2.CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n\n      case _gesture2.CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n\n      case _gesture2.CALLBACK_TYPE.END:\n        return gesture.onEnd;\n\n      case _gesture2.CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n\n      case _gesture2.CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n\n      case _gesture2.CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n\n      case _gesture2.CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n\n      case _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType) {\n    'worklet';\n\n    switch (eventType) {\n      case _EventType.EventType.TOUCHES_DOWN:\n        return _gesture2.CALLBACK_TYPE.TOUCHES_DOWN;\n\n      case _EventType.EventType.TOUCHES_MOVE:\n        return _gesture2.CALLBACK_TYPE.TOUCHES_MOVE;\n\n      case _EventType.EventType.TOUCHES_UP:\n        return _gesture2.CALLBACK_TYPE.TOUCHES_UP;\n\n      case _EventType.EventType.TOUCHES_CANCELLED:\n        return _gesture2.CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n\n    return _gesture2.CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(type, gesture, event) {\n    'worklet';\n\n    var handler = getHandler(type, gesture);\n\n    if (gesture.isWorklet[type]) {\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n\n      handler === null || handler === void 0 ? void 0 : handler.apply(void 0, [event].concat(args));\n    } else if (handler) {\n      console.warn((0, _utils.tagMessage)('Animated gesture callback must be a worklet'));\n    }\n  }\n\n  var sharedHandlersCallbacks = _reanimatedWrapper.Reanimated.useSharedValue(null);\n\n  var lastUpdateEvent = _reanimatedWrapper.Reanimated.useSharedValue([]);\n\n  var stateControllers = [];\n\n  var callback = function callback(event) {\n    'worklet';\n\n    var currentCallback = sharedHandlersCallbacks.value;\n\n    if (!currentCallback) {\n      return;\n    }\n\n    for (var i = 0; i < currentCallback.length; i++) {\n      var gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (event.oldState === _State.State.UNDETERMINED && event.state === _State.State.BEGAN) {\n            runWorklet(_gesture2.CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if ((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) && event.state === _State.State.ACTIVE) {\n            runWorklet(_gesture2.CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (event.oldState !== event.state && event.state === _State.State.END) {\n            if (event.oldState === _State.State.ACTIVE) {\n              runWorklet(_gesture2.CALLBACK_TYPE.END, gesture, event, true);\n            }\n\n            runWorklet(_gesture2.CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if ((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) && event.state !== event.oldState) {\n            if (event.oldState === _State.State.ACTIVE) {\n              runWorklet(_gesture2.CALLBACK_TYPE.END, gesture, event, false);\n            }\n\n            runWorklet(_gesture2.CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = _gestureStateManager.GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== _EventType.EventType.UNDETERMINED) {\n            runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);\n          }\n        } else {\n          runWorklet(_gesture2.CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            var _gesture$changeEventC;\n\n            runWorklet(_gesture2.CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  var event = _reanimatedWrapper.Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], needsRebuild);\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\nvar GestureDetector = function GestureDetector(props) {\n  var _gestureConfig$toGest, _gestureConfig$toGest2;\n\n  var gestureConfig = props.gesture;\n  var gesture = (_gestureConfig$toGest = gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$toGest2 = gestureConfig.toGestureArray) === null || _gestureConfig$toGest2 === void 0 ? void 0 : _gestureConfig$toGest2.call(gestureConfig)) !== null && _gestureConfig$toGest !== void 0 ? _gestureConfig$toGest : [];\n  var useReanimatedHook = gesture.some(function (g) {\n    return g.shouldUseReanimated;\n  });\n  var viewRef = (0, _react.useRef)(null);\n  var firstRenderRef = (0, _react.useRef)(true);\n\n  var preparedGesture = _react.default.useRef({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useReanimatedHook: useReanimatedHook\n  }).current;\n\n  if (useReanimatedHook !== preparedGesture.useReanimatedHook) {\n    throw new Error((0, _utils.tagMessage)('You cannot change the thread the callbacks are ran on while the app is running'));\n  }\n\n  var needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    var _gestureConfig$initia;\n\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$initia = gestureConfig.initialize) === null || _gestureConfig$initia === void 0 ? void 0 : _gestureConfig$initia.call(gestureConfig);\n  }\n\n  if (useReanimatedHook) {\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  (0, _react.useEffect)(function () {\n    firstRenderRef.current = true;\n    var viewTag = (0, _gestureHandlerCommon.findNodeHandle)(viewRef.current);\n    attachHandlers({\n      preparedGesture: preparedGesture,\n      gestureConfig: gestureConfig,\n      gesture: gesture,\n      viewTag: viewTag\n    });\n    return function () {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  (0, _react.useEffect)(function () {\n    if (!firstRenderRef.current) {\n      var viewTag = (0, _gestureHandlerCommon.findNodeHandle)(viewRef.current);\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture: preparedGesture,\n          gestureConfig: gestureConfig,\n          gesture: gesture,\n          viewTag: viewTag\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  var refFunction = function refFunction(ref) {\n    if (ref !== null) {\n      viewRef.current = ref;\n\n      if ((0, _utils.isFabric)()) {\n        var node = (0, _getShadowNodeFromRef.getShadowNodeFromRef)(ref);\n\n        if (global.isFormsStackingContext(node) === false) {\n          setImmediate(function () {\n            console.error((0, _utils.tagMessage)('GestureDetector has received a child that may get view-flattened. ' + '\\nTo prevent it from misbehaving you need to wrap the child with a `<View collapsable={false}>`.'));\n          });\n        }\n      }\n    }\n  };\n\n  if (useReanimatedHook) {\n    return _react.default.createElement(AnimatedWrap, {\n      ref: refFunction,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler\n    }, props.children);\n  } else {\n    return _react.default.createElement(Wrap, {\n      ref: refFunction\n    }, props.children);\n  }\n};\n\nexports.GestureDetector = GestureDetector;\n\nvar Wrap = function (_React$Component) {\n  (0, _inherits2.default)(Wrap, _React$Component);\n\n  var _super = _createSuper(Wrap);\n\n  function Wrap() {\n    (0, _classCallCheck2.default)(this, Wrap);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Wrap, [{\n    key: \"render\",\n    value: function render() {\n      var child = _react.default.Children.only(this.props.children);\n\n      return _react.default.cloneElement(child, {\n        collapsable: false\n      }, child.props.children);\n    }\n  }]);\n  return Wrap;\n}(_react.default.Component);\n\nvar AnimatedWrap = (_Reanimated$default$c = _reanimatedWrapper.Reanimated === null || _reanimatedWrapper.Reanimated === void 0 ? void 0 : (_Reanimated$default = _reanimatedWrapper.Reanimated.default) === null || _Reanimated$default === void 0 ? void 0 : _Reanimated$default.createAnimatedComponent(Wrap)) !== null && _Reanimated$default$c !== void 0 ? _Reanimated$default$c : Wrap;","map":{"version":3,"sources":["GestureDetector.tsx"],"names":["ALLOWED_PROPS","ref","interactionGroup","tag","preparedGesture","RNGestureHandlerModule","handler","unregisterHandler","gesture","areSomeNotWorklets","areSomeWorklets","console","viewTag","gestureConfig","setImmediate","checkGestureCallbacksForWorklets","filterConfig","registerHandler","requireToFail","extractValidHandlerTags","simultaneousWith","simultaneousHandlers","waitFor","actionType","ActionType","isAnimatedGesture","g","i","event","CALLBACK_TYPE","EventType","getHandler","tagMessage","sharedHandlersCallbacks","Reanimated","lastUpdateEvent","stateControllers","callback","currentCallback","isStateChangeEvent","State","runWorklet","isTouchEvent","GestureStateManager","touchEventTypeToCallbackType","GestureDetector","props","useReanimatedHook","viewRef","useRef","firstRenderRef","config","animatedEventHandler","animatedHandlers","firstExecution","needsToRebuildReanimatedEvent","needsToReattach","useAnimatedGesture","useEffect","findNodeHandle","attachHandlers","dropHandlers","updateHandlers","refFunction","node","getShadowNodeFromRef","global","React","render","child","collapsable","AnimatedWrap"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\nimport { ActionType } from '../../ActionType';\nimport { isFabric, tagMessage } from '../../utils';\nimport { getShadowNodeFromRef } from '../../getShadowNodeFromRef';\n\ndeclare global {\n  function isFormsStackingContext(node: unknown): boolean | null; // JSI function\n}\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useReanimatedHook: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag, handler.config.testId);\n  }\n}\n\nfunction checkGestureCallbacksForWorklets(gesture: GestureType) {\n  // if a gesture is explicitly marked to run on the JS thread there is no need to check\n  // if callbacks are worklets as the user is aware they will be ran on the JS thread\n  if (gesture.config.runOnJS) {\n    return;\n  }\n\n  const areSomeNotWorklets = gesture.handlers.isWorklet.includes(false);\n  const areSomeWorklets = gesture.handlers.isWorklet.includes(true);\n\n  // if some of the callbacks are worklets and some are not, and the gesture is not\n  // explicitly marked with `.runOnJS(true)` show an error\n  if (areSomeNotWorklets && areSomeWorklets) {\n    console.error(\n      tagMessage(\n        `Some of the callbacks in the gesture are worklets and some are not. Either make sure that all calbacks are marked as 'worklet' if you wish to run them on the UI thread or use '.runOnJS(true)' modifier on the gesture explicitly to run all callbacks on the JS thread.`\n      )\n    );\n  }\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    checkGestureCallbacksForWorklets(handler);\n\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler, handler.config.testId);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    const actionType = gesture.shouldUseReanimated\n      ? ActionType.REANIMATED_WORKLET\n      : ActionType.JS_FUNCTION_NEW_API;\n\n    RNGestureHandlerModule.attachGestureHandler(\n      gesture.handlerTag,\n      viewTag,\n      actionType\n    );\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    const isAnimatedGesture = (g: GestureType) => g.shouldUseReanimated;\n\n    preparedGesture.animatedHandlers.value = (gesture\n      .filter(isAnimatedGesture)\n      .map((g) => g.handlers) as unknown) as HandlerCallbacks<\n      Record<string, unknown>\n    >[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config\n        .filter((g) => g.shouldUseReanimated) // ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown) as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (\n      gesture[i].handlerName !== preparedGesture.config[i].handlerName ||\n      gesture[i].shouldUseReanimated !==\n        preparedGesture.config[i].shouldUseReanimated\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(\n  preparedGesture: GestureConfigReference,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn(tagMessage('Animated gesture callback must be a worklet'));\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useReanimatedHook = gesture.some((g) => g.shouldUseReanimated);\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useReanimatedHook: useReanimatedHook,\n  }).current;\n\n  if (useReanimatedHook !== preparedGesture.useReanimatedHook) {\n    throw new Error(\n      tagMessage(\n        'You cannot change the thread the callbacks are ran on while the app is running'\n      )\n    );\n  }\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useReanimatedHook) {\n    // Whether animatedGesture or gesture is used shouldn't change while the app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  const refFunction = (ref: unknown) => {\n    if (ref !== null) {\n      //@ts-ignore Just setting the ref\n      viewRef.current = ref;\n\n      if (isFabric()) {\n        const node = getShadowNodeFromRef(ref);\n        if (global.isFormsStackingContext(node) === false) {\n          setImmediate(() => {\n            // For some weird reason, console.error on iOS delays\n            // the execution of RNGestureHandlerModule.attachGestureHandler,\n            // so that's why we use setImmediate here.\n            console.error(\n              tagMessage(\n                'GestureDetector has received a child that may get view-flattened. ' +\n                  '\\nTo prevent it from misbehaving you need to wrap the child with a `<View collapsable={false}>`.'\n              )\n            );\n          });\n        }\n      }\n    }\n  };\n\n  if (useReanimatedHook) {\n    return (\n      <AnimatedWrap\n        ref={refFunction}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={refFunction}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"]},"metadata":{},"sourceType":"script"}